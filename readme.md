# MZ-1500 Sound System

MZ-1500向けの音楽ドライバ・MMLコンパイラー・Windows用プレビュー再生環境を統合した開発プロジェクトです。

## 特徴
* **MZ-1500のフルスペック活用**: 内蔵された DCSG×2 + 8253 BEEP（合計: 矩形波7ch + ノイズ2ch）の強大なサウンド能力を全開で制御します。
* **強力なMMLからの入力**: 表現力豊かな独自MMLフォーマットを用いた音楽作成が可能。将来的にGUIベースの入力へも拡張可能な内部設計を採用します。
* **Windowsで手軽に再生確認**: 実機やエミュレータをわざわざ起動・転送することなく、C#で書かれたエミュレーションレイヤーを通してWindows上で即座にプレビュー再生が可能です。
* **qdc形式への出力**: MZ-1500実機や各種エミュレータで読み込み・実行可能な Quick Disk (qdc) フォーマット等への直接出力に対応します。

## 開発環境
* 言語: C# .NET 9.0
* 対象環境: Windows

---

# MZ-1500 サウンドドライバ仕様書

## 1. 概要
SHARP MZ-1500 のサウンド機能コンポーネントを最大限に引き出すための音楽制作環境（MMLコンパイラ＋再生環境＋ドライバ）を構築する。
Windows環境にてC# .NET 9.0を用いて作成し、Windows上での直接再生(手軽なプレビュー体験)と、MZ-1500実機・エミュレータ向けファイル（qdcフォーマット）出力の両立を目指す。

## 2. ターゲットハードウェア仕様 
MZ-1500のサウンド仕様は以下の通り：
* **DCSG 1 (SN76489互換)**: 矩形波 x 3, ノイズ x 1
* **DCSG 2 (SN76489互換)**: 矩形波 x 3, ノイズ x 1
* **BEEP (Intel 8253)**: 単音(矩形波)
* **最大同時発音数**: 矩形波7ch + ノイズ2ch

## 3. ソフトウェア構成
本システムは以下の主要コンポーネントから構成される：
1. **MMLコンパイラ (Windows / C# .NET 9.0)**
   * 「強力なMML」テキストフォーマットをパースし、各チャンネル向けのシーケンスデータへ変換する。
2. **プレビュープレイヤ (Windows / C# .NET 9.0)**
   * コンパイルされたデータをWindows上で即座に再生する。
   * 波形合成によりDCSGおよびBEEPの挙動をエミュレートする。
   * 再生中にリアルタイムで各チャンネル (`A`-`H`, `P`) のON/OFFを切り替えられる**チャンネルマスク（ミュート）機能**を搭載。
   * **MIDIインポート機能**: `.mid` ファイルを読み込み、MML文字列データへ自動変換（モノフォニック間引き処理、テンポ自動抽出、`100`文字ごとの改行）を行うユーティリティを内包。
3. **qdcエクスポータ (Windows / C# .NET 9.0)**
   * MZ-1500エミュレータ/実機で読み込み可能なqdc (Quick Disk) イメージ等へ書き出す。
4. **サウンドドライバ (MZ-1500 / Z80 Assembly)**
   * MZ-1500上で動作し、生成されたデータを読み込みながらDCSG/BEEPを制御・発音する再生用ドライバプログラム。

## 4. MML仕様方針 (強力なMML入力)
将来的にGUI入力（トラッカーやピアノロール）にも対応できるよう、中間オブジェクト(AST)への変換を前提とした汎用的な設計を行う。
当面のテキストMMLでの表現力として以下を想定する：
* **音階・音符**: `c d e f g a b`, `+ -` (シャープ/フラット), `,` (付点), 音長指定 など標準記法
* **トラック/チャンネルルーティング**: DCSG1, DCSG2, BEEP への任意割り当て
* **高度な表現**: ソフトウェアエンベロープ(音量, ピッチ), LFOレイヤー (ビブラート, ポルタメント, アルペジオ, ピッチスイープ)
* **制御構文**: 多重ループ `[ ]` 構文や、反復記号、マクロ展開機能

### 4.1 基本MMLコマンド仕様
| コマンド | 内容 | 解析および処理イメージ |
| :--- | :--- | :--- |
| `A`-`H`, `P` | トラック定義 | 行頭で指定された文字で書き込み先トラックを切り替える。複数記述可。A-CはPSG1(矩形)、E-GはPSG2(矩形)。D,Hはノイズ。PはBEEP。 |
| `t`, `@t` | テンポ指定 | `t150` または `@t1,86` のような記法。四分音符長からTickやサンプル長へ変換。 |
| `o` | オクターブ | `o4` なら中央のド付近。 |
| `<>` | オクターブ増減 | `currentOctave++` または `--`。 |
| `l` | デフォルト音長| `l4` なら四分音符。 |
| `v`, `@v`| 音量/エンベロープ指定| `v15` 等の音量指定、およびソフトウェアエンベロープ番号指定。
| `[ ]n` | 繰り返しループ | 括弧内のフレーズを `n` 回繰り返す。`n` を省略した場合は2回とみなす。多重ループ（入れ子）にも対応する。 |
| `a-g` (+-#) | 音名 | 音名とオクターブから周波数を決定。直後の数値で音長指定、`.` で付点。 |
| `r` | 休符 | 周波数を0（無音）として指定時間待機。 |
| `^` | タイ | 音の長さを繋げる。例) `c4^8` で4分音符+8分音符 |
| `q`, `@q` | ゲート制限 | 発音時間の何％(`q`) / 何フレーム(`@q`) を鳴らすかの計算 (クオンタイズ)。 |
| `D` | ディチューン | セント単位でトラック全体のピッチをずらす指定。例) `D10`, `D-20` |
| `EP`, `@p` | ピッチエンベロープ | ソフトウェアピッチエンベロープの適用（ID指定）、または `EP255`等で解除。 |
| `@wn` | ノイズ波形指定 | ノイズ専用トラック(D, H)の波形指定。`@wn0`: 周期ノイズ(メタリック音), `@wn1`: ホワイトノイズ(標準)。 |
| `@in` | ノイズ連動指定 | トーン専用トラック(C, G)とノイズ(D, H)の同期駆動指定。`@in0`: オフ, `@in1`: 周期, `@in2`: ホワイト。 |
| `L` | ループポイント| 曲の終わりに到達した際、このマーカー位置へ戻って永続ループする。 |
詳細はmml_reference.mdを参照。

### 4.2 ソフトウェア音量エンベロープ (`@v`) 仕様
MZ-1500のSN76489互換音源モジュールはハードウェアによる自動減衰エンベロープを持たないため、本システムではソフトウェア制御による疑似エンベロープ（音量変化）記法をサポートする。

#### エンベロープデータの定義
- トラック記述領域（曲の先頭など）にて、`@v[番号] = { ボリューム値1, 定数値2... }` の形式で定義する。
- **配列の要素数**: 任意の長さ。フレーム(60Hz=約16.6ms)単位での音量推移を示す。
- **ボリューム値**: `0` (無音) ～ `15` (最大音量) までの整数値。
- **ループ指定**: 配列の途中に `|` を記述すると、末尾に到達した際にその位置へ戻ってループ再生を繰り返す。
- **終端マーカ**: `|` が無い場合は、内部的には配列の末尾到達時に最後の音量値を維持し続ける。

**定義例:**
```mml
@v0 = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
@v1 = {15, 14, 13, |, 12, 11, 10} ; 10の次は12に戻る
@v2 = {15,15,15,15, 10,10,10,10, 5,5,5,5, 0}
```

#### エンベロープの適用・解除
- 対象のトラック内で `@v[定義番号]` を記述すると、それ以降の音符発音時に定義したエンベロープ波形が自動適用される。
- エンベロープ適用中は、通常の `v` コマンド(固定音量)による指定はオーバーライドされる。
- エンベロープを解除(OFF)して通常の固定音量に戻す場合は `@v` (番号なし) を記述する。

**適用例:**
```mml
A o4 l8 @v0 c d e @v1 f g @v a b >c
```

#### 内部実装（Z80ドライバおよびWindowsプレビュー）
- **C# プレビュー再生**: 波形生成オシレータ内で、`60Hz`相当のサンプル経過時間をインデックスとして配列を参照し、`0-15`の値を浮動小数点ボリュームに変換して乗算する。
- **Z80ドライバ (qdc)**: コンパイラが割り当てたエンベロープデータテーブル領域を参照。割り込み周期(1/60秒)ごとにデータを1バイト読み出してSN76489のボリュームレジスタ(`1001ccvv`)を叩き、フェードアウト/ポルタメント等の音量推移を表現する。各音符(Note On)の読み込み時にエンベロープポインタは先頭(`0x00`)へリセットされる。

### 4.3 ソフトウェアピッチエンベロープ (`@EP`) 仕様
ビブラートやピッチベンドなどの滑らかな音程変化をソフトウェアで実現するためのエンベロープ定義です。本システムでは **「Cents (セント) 値（1ユニット = 1セント）」** を基本単位として変動配列を構築します。

#### ピッチデータの定義
- 領域先頭などで `@EP[番号] = { セント変動1, セント変動2... }` の形式で定義する (例: `@EP0 = {0, 10, 20}`).
- **セント値**: 負の数も指定可能。100セントで半音の変動となる。
- **機能**: 音量エンベロープ `~|~` と同様のループ定義マーカー `|` をサポートする。

#### エンベロープの適用・解除
対象トラックで `EP[番号]` を指定すると以後の音符の周波数推移にセント変動が掛かる。`EP255` で元の周波数（ピッチエンベロープなし）に戻る。

#### 内部実装（ハードウェア向け最適化）
Z80上でセントからHzへの浮動小数点演算は負荷が高すぎるため、**C#のプレビュー/コンパイル時点ですべて「Z80用 10ビット絶対レジスタ値」への変換** (HwPitchEnv) を済ませておき、Z80側は音量エンベロープと同様に配列を毎フレームポインタ参照して出力するだけの軽量設計となっている。

### 4.4 MIDI インポートと MML 自動フォーマット
外部シーケンサで作成されたMIDIファイル (`.mid`) を読み込み、本ドライバ仕様のMMLへ自動変換する機能を備える。
- **チャンネル自動割り当て**: 読み込んだMIDIトラック順に `A`, `B`, `C`... `H`, `P` へ割り当てる。
- **モノフォニック化**: MML仕様に合わせて和音は間引き（最高音優先）される。
- **テンポ指定**: MIDI内の `TempoEvent` を抽出し、全マッピング済みチャンネルをプレフィックスとして `ABC t120` 形式で出力する。
- **改行フォーマット**: トラックごとのMML行は可読性確保のため約100文字で改行（インデント）される。改行された次行の先頭には、該当するチャンネル文字（例: `A `）が自動補完される。

### 4.5 UIおよびエディタ機能の拡張
本システムはWindows上のGUI (Avalonia UI) を通して、IDE(統合開発環境)ライクな使い勝手を提供します。

- **プレイスルー・ハイライト機能**: プレビュー再生において、C#の高精度な`Stopwatch`を用いて内部時間を計測し、AvaloniaEdit上で現在発音している「ノート（音符）」のテキスト背景色をリアルタイムに同時ハイライト（黄色）描画します。複数トラックの同時発音・進行にも対応し、視覚的なデバッグを強力に補助します。
- **選択範囲の部分再生 (Partial Playback)**: エディタ上で特定のMML文法をドラッグ選択して「Play MML」を押すと、テンポ(`t`)やオクターブ(`o`)、エンベロープ状態などを維持したまま、**選択された範囲の音符のみ**を瞬時に抽出・発音部だけをプレビュー再生します。
- **スマート・チャンネルリマップ**: 各トラック(A〜H, P)のアサイン先を一括置換するダイアログ機能を備えます。選択不可な（未使用の）チャンネルは自動で非活性化処理(`Disabled`)が行われ、正規表現と一時タグ(`_TMP_`)を用いた安全な置換アルゴリズムにより、トラック間のスワップ(交換)操作等でもテキストデータが破壊されません。
- **VSCode風ダークテーマ**: `AvaloniaEdit`のカスタムシンタックスハイライト(`MmlSyntax.xshd`)を用いて、目に優しいインテリセンスライクなダークテーマレイアウト（パステルカラーによる色分け）を実現しています。

## 5. 技術スタック
* 開発言語: C# .NET 9.0 (ツールチェイン本体), Avalonia UI (GUIフロントエンド)
* 音声処理: NAudio (波形合成, MIDIファイル解析)
* Z80クロスアセンブラ: z80asm や rasm 等（検討中）

## 6. 将来の拡張
* CLIベースでのコンパイル・プレビュー再生からのスタートとし、コアをライブラリ化（DLL化）しておくことで、その上位レイヤーにGUIフロントエンド(WPF, WinForms, Avalonia等)を被せられるアーキテクチャ設計とする。
