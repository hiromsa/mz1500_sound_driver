# Mz1500SoundPlayer: プロジェクト設計・実装仕様書

## 1. プロジェクトの目的と設計思想
本プロジェクト「Mz1500SoundPlayer」は、**SHARP MZ-1500** 向けに、MML（Music Macro Language）を用いて高機能な音楽再生を行うための「クロス環境サウンドドライバ＆オーサリングツール」です。

### 1.1 設計思想 (Philosophy)
1. **「Write Once, Play Anywhere (MZ & PC)」**
   * 1つのMMLソースコードから、PC上（Windows/Mac/Linux上のC#アプレット等）での「事前プレビュー再生」と、実機/エミュレータ上のZ80マシン語としての「ネイティブ再生」の両方を、**全く同じニュアンス**で出力することを目指しています。
2. **「アセンブリコードのDSL化 (Domain Specific Language)」**
   * Z80のアセンブリコードを外部のCコンパイラやアセンブラツール(z80asm等)に依存せず、C#コード内の「Z80ビルダーAPI (`Z80Parts.cs`, `MZ1500MusicAssembler.cs`)」として定義します。これにより、C#の強力な動的生成能力を活かして、曲データに合わせた最適なコードサイズ・処理パタンを動的にアセンブル可能にしています。
3. **「PCリソースを活かしたクロスコンパイル」**
   * Z80のような非力なCPU上でMMLを動的にパースするのは負荷が高いため、PC側（C#）でMMLの構文解析・展開（マクロやループの展開など）を全て済ませ、**Z80側には「あとは垂れ流すだけの軽量なコマンド列（バイトコード）」として渡す**ファット・コンパイラ／シン・クライアント方式を採用しています。

---

## 2. システム・アーキテクチャ

システムは大きく分けて「MML解析・展開部」「PC用プレビュー再生部」「Z80コンパイル＆アセンブル部」の3層から構成されています。

### 2.1 MML解析・展開部 (MML Frontend)
ユーザーが入力したテキストのMMLデータを解析し、時間の情報を含んだ「NoteEvent」のリストへ変換します。

* **`MmlAst.cs`**: 
  MMLの抽象構文木(AST)のデータ構造。`TrackData`（トラック名とコマンドリスト）、`EnvelopeData`（ソフトウェアエンベロープのボリューム配列とループ地点の保持）、各種音符・記号のクラス定義を持ちます。
* **`MultiTrackMmlParser.cs` / `MmlParser.cs`**:
  文字列のMMLをトークン化し、ASTへ変換します。正規表現などを駆使し、複雑なエンベロープ定義 `@v`、ピッチエンベロープ `@EP` や複数トラックのヘッダ解析などを行います。
* **`TrackEventExpander.cs`**:
  ASTを受け取り、テンポ(`@t`)、音符・休符の長さ、付点、クオンタイズ(`@q`, `q`)、ピッチエンベロープ(`EP`)指定などの文脈ステートをシミュレーションしながら、「周波数(Hz)」「継続時間(ms)」「発音時間/Gate(ms)」「ボリューム」などが確定した**絶対的な時間軸上のイベントリスト (`NoteEvent`)** に平坦化(フラット化)します。ループなどの構造もこの段階で一つなぎのリストへ展開されます。

### 2.2 PC用プレビュー再生部 (PC Audio Player, Z80 VM Engine)
Z80実機に持っていく前に、PC上でMMLの鳴りを確認するためのオーディオエンジンです。実機との発音タイミングや状態（ステート）差異によるバグを防ぐため、PC内でも**Z80バイトコードの仮想マシン（VM）**を動作させてシミュレーション再生を行います。

* **`MmlPlayerModel.cs`**:
  NAudio (WasapiOut等) を利用し、オーディオ再生のストリームを管理・制御します。このクラス内でAST展開イベントを一時的に `MmlToZ80Compiler` に通してZ80バイトコードへとコンパイルし、それをシーケンスプロバイダに引き渡します。
* **`MultiTrackSequenceProvider.cs`**:
  コンパイル済みのZ80バイトコード（`byte[]`）の辞書を受け取り、全トラックのオーディオストリームをミキシングして出力します。
* **`MmlSequenceProvider.cs` (Z80 Virtual Machine)**:
  `ISampleProvider` の実装クラスであり、内部に**「Z80仮想マシン」**を持っています。受け取ったZ80バイトコードを `1/60` 秒（1フレーム）の解像度でTick実行・インクリメントし、Z80プログラムカウンタ(`_pc`)やタイマー(`WaitFrames`)、エンベローポインタのステート変化を完全に実機サウンドドライバと同じレベル・順序でエミュレーション波形合成（矩形波出力）を行います。ソフトウェアエンベロープの反転計算などもハードウェア仕様通りにシミュレーションします。
* **`SimpleSquareWaveProvider.cs`**:
  ファミコンやMZ系のPSG(SN76489)特有の「矩形波」を発振する、最も低レベルなオシレータです。

### 2.3 Z80コンパイル＆アセンブル部 (Z80 Backend)
MZ-1500実機で動かすためのZ80バイトコードを生成し、ブート可能なQDC（Quick Disk）イメージとして書き出します。

* **`MmlToZ80Compiler.cs` (バイトコード変換器)**:
  `NoteEvent` の経過時間(ms)をMZ-1500のフレーム（1/60秒＝60Hz）単位に変換します。SN76489のレジスタ計算式 (`111860 / Hz`) に基づき周波数データを10bitの数値へ変換し、『音符出し(CMD_TONE)』『無音・休符(CMD_REST)』『音量変更(CMD_VOL)』『音量エンベロープ変更(CMD_ENV)』『ピッチエンベロープ変更(CMD_PENV)』などに分かれた独自の軽量バイトコード列へシリアライズします。
  また、ここで MML上の「セント単位のピッチエンベロープ変動」と「音符の基本周波数」から、Z80ハードウェア用の「10bit絶対レジスタ値配列 (`HwPitchEnvelopes`)」を全パターン静的生成し、Z80側の計算負荷をゼロにする高度な最適化を行います。
* **`Z80Parts.cs`**:
  Z80のオペコード（`LD`, `JP`, `CP`, `OUT` 等）やレジスタ、分岐条件、ラベル相対参照のアドレス解決機能をC#オブジェクトとして組み上げた、**インメモリZ80アセンブラコア**です。
* **`MZ1500MusicAssembler.cs`**:
  `Z80Parts` を用いて、MZ-1500向けの実機サウンドドライバの命令セットを生成します。
  1/60sのVBLANK相当クロック（またはソフトウェアディレイクロック）で駆動する再生ループ、エンベロープ処理（`0xFE`判定によるメモリ上のループ処理等）、ハードウェアへのI/O `OUT` を全てここでC#のメソッドチェーン的に組み立て、最終的なマシン語の `.bin` 配列を出力します。
* **`QdcImageBuilder.cs`**:
  生成されたZ80のバイナリプログラムを、MZ-1500のエミュレータ・実機がそのままロードして実行できるQuick Disk(QDC)のファイルフォーマット（ヘッダやブロック構造）にパッケージングします。

---

## 3. 重要機能の実装仕様

### 3.1 ソフトウェア音量エンベロープ機能 (`@v`)
SN76489はハードウェアにADSRなどのエンベロープ機能がないため、プログラムで毎フレーム細かく音量レジスタを叩く必要があります。
- **MML側**: `@v1={15,14,12|10,8,5}` のように定義。`|` 以降がサステイン時のループ区間。
- **PC側 (`MmlSequenceProvider`)**: ストリーム生成ループの中で、対象音符の経過サンプル数からフレームインデックスを算出し、配列の範囲を超えたら `LoopIndex` を用いて modulo(余り) 計算を行い、シームレスなループ波形を生成します。
- **Z80側 (`MZ1500MusicAssembler`)**:
  コンパイル時にエンベロープデータをドライバのアセンブリコード末尾にデータテーブルとして埋め込みます。`|` があった場合はリスト末尾に `[0xFE, 対象オフセット]` という制御バイトを追加します。
  再生中（60Hz間隔）、メモリから音量データを読み取り `0xFE` に遭遇した場合は、続くオフセットバイトを取り出して現在読み取りポインタを巻き戻し、無限ループを実現します。新しく音が鳴り始める瞬間にポインタは常に `0` にリセットされます。

### 3.2 ソフトウェアピッチエンベロープ機能 (`@EP`)
ハードウェアでサポートされていないビブラートやピッチベンドをソフトウェア実装します。
- **コンパイル処理**: Z80上で都度浮動小数点のHzやセントの計算を行うのは負荷の観点から不可能なため、C#の `MmlToZ80Compiler` 内で「対象音符のベース周波数 × セント変動配列」をすべて1フレ単位のSN76489レジスタの生値(0〜1023) 2バイト列に変換したテーブル(`HwPitchEnvelopes`)を事前作成します。
- **Z80バイトコード**: バイトコードとしては `CMD_PENV` にその生成したテーブルIDを渡すのみに圧縮します。
- **Z80再生処理**: 割り込みハンドラの `OutputSoundByStatus` 実行時に、`CMD_PENV` によって指定された絶対レジスタ値の配列要素(1フレームにつき2バイト)をポインタ参照し、加工なしで直接PSGの周波数レジスタへ `OUT` 送信します。ボリューム同様に `0xFE` 制御バイトによるループにも対応しています。

### 3.3 Gate / Quantize (`q` / `@q`)
スタッカートなど、音符の途中で音を短く切る表現です。
- **コンパイル処理**: `TrackEventExpander` により、`TotalDuration` と `GateDuration` (実際に発音する時間)、およびその差分である `RestDuration` (無音となる時間) に分離されます。
- **Z80バイトコード**: `CMD_TONE` の直後に「発音する長さ分」のWaitを設定し、その後ろに必ず `CMD_REST`（Mute `OUT` 命令＋無音Wait）を挿入することで、ハードウェアの矩形波出力でもキレの良いスタッカートを再現します。

## 4. プログラムエントリーポイント
* **`Program.cs / App.axaml` (Avalonia UI UI層)**
  Avaloniaを利用したテキストエディタベースのUI画面を備え、再生ボタンが押されると `MmlPlayerModel.Play()` を呼び出してPCオーディオを鳴らし、エクスポートボタンで `ExportQdc()` を呼び出してQDCファイルをバイナリ保存します。コマンドライン引数（`test`）を使ったヘッドレスなCUIコンパイルデバッグ基盤も備えています。
